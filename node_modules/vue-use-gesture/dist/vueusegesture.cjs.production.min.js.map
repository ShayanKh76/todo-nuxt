{"version":3,"file":"vueusegesture.cjs.production.min.js","sources":["../src/utils/math.ts","../src/utils/rubberband.ts","../src/utils/utils.ts","../src/utils/resolveOptionsWith.ts","../src/utils/config.ts","../src/hooks/buildConfig.ts","../src/utils/state.ts","../src/recognizers/Recognizer.ts","../src/Controller.ts","../src/hooks/useRecognizers.ts","../src/recognizers/CoordinatesRecognizer.ts","../src/utils/event.ts","../src/recognizers/DragRecognizer.ts","../src/utils/memoize-one.ts","../src/utils/react-fast-compare.ts","../src/recognizers/PinchRecognizer.ts","../src/recognizers/DistanceAngleRecognizer.ts","../src/recognizers/WheelRecognizer.ts","../src/recognizers/MoveRecognizer.ts","../src/recognizers/ScrollRecognizer.ts","../src/hooks/useGesture.ts","../src/useSpring/presets.ts","../src/useSpring/utils.ts","../src/useSpring/motion.ts","../src/hooks/useDrag.ts","../src/hooks/useHover.ts","../src/hooks/useMove.ts","../src/hooks/usePinch.ts","../src/hooks/useScroll.ts","../src/hooks/useWheel.ts"],"sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\ninterface Kinematics {\n  velocities: number[]\n  velocity: number\n  distance: number\n  direction: number[]\n}\n\nexport function calculateAllGeometry<T extends number[]>(movement: T, delta: T = movement) {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n\n  const direction = delta.map((v) => alpha * v) as T\n  const distance = calculateDistance(movement)\n\n  return { distance, direction }\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, dt: number): Kinematics {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n  const beta = dt === 0 ? 0 : 1 / dt\n\n  const velocity = beta * dl\n  const velocities = delta.map((v) => beta * v)\n  const direction = delta.map((v) => alpha * v)\n  const distance = calculateDistance(movement)\n\n  return { velocities, velocity, distance, direction }\n}\n\n/**\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\n * This polyfill function is suggested by Mozilla:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n * @param x target number\n */\nexport function sign(x: number) {\n  if (Math.sign) return Math.sign(x)\n  return Number(x > 0) - Number(x < 0) || +x\n}\n","function minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n  if (position < min) return -rubberband(min - position, max - min, constant) + min\n  if (position > max) return +rubberband(position - max, max - min, constant) + max\n  return position\n}\n","export function noop() {}\n\n/**\n * TODO Beware that only optimized cases are covered in tests =)\n * TODO Need to cover general case as well\n *\n * @param fns\n */\nexport function chainFns(...fns: Function[]): Function {\n  if (fns.length === 0) return noop\n  if (fns.length === 1) return fns[0]\n\n  return function (this: any) {\n    var result\n    for (let fn of fns) {\n      result = fn.apply(this, arguments) || result\n    }\n    return result\n  }\n}\n\n/**\n * Expects a simple value or 2D vector (an array with 2 elements) and\n * always returns 2D vector. If simple value is passed, returns a\n * vector with this value as both coordinates.\n *\n * @param value\n */\nexport function ensureVector<T>(value: T | [T, T] | undefined, fallback?: T | [T, T]): [T, T] {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected')\n    }\n    value = fallback\n  }\n\n  if (Array.isArray(value)) return value\n  return [value, value]\n}\n\n/**\n * Helper for defining a default value\n *\n * @param value\n * @param fallback\n */\nexport function assignDefault<T extends Object>(value: Partial<T> | undefined, fallback: T): T {\n  return Object.assign({}, fallback, value || {})\n}\n\n/**\n * Resolves getters (functions) by calling them\n * If simple value is given it just passes through\n *\n * @param v\n */\nexport function valueFn<T>(v: T | ((...args: any[]) => T), ...args: any[]): T {\n  if (typeof v === 'function') {\n    // @ts-ignore\n    return v(...args)\n  } else {\n    return v\n  }\n}\n","export type Resolver = (x: any, key: string, obj: object) => any\nexport type ResolverMap = { [k: string]: Resolver | ResolverMap | boolean }\n\nexport function resolveWith<T extends { [k: string]: any }, V extends { [k: string]: any }>(\n  config: Partial<T> = {},\n  resolvers: ResolverMap\n): V {\n  const result: any = {}\n\n  for (const [key, resolver] of Object.entries(resolvers))\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config)\n        break\n      case 'object':\n        result[key] = resolveWith(config[key], resolver)\n        break\n      case 'boolean':\n        if (resolver) result[key] = config[key]\n        break\n    }\n\n  return result\n}\n","import { ensureVector, assignDefault, valueFn } from './utils'\nimport { resolveWith } from './resolveOptionsWith'\n\nimport {\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n  Vector2,\n  Bounds,\n  StateKey,\n  State,\n  CoordinatesKey,\n  DistanceAngleKey,\n} from '../types'\n\nexport const DEFAULT_DRAG_DELAY = 180\nexport const DEFAULT_RUBBERBAND = 0.15\nexport const DEFAULT_SWIPE_VELOCITY = 0.5\nexport const DEFAULT_SWIPE_DISTANCE = 60\n\nconst InternalGestureOptionsNormalizers = {\n  threshold(value: number | Vector2 = 0) {\n    return ensureVector(value)\n  },\n\n  rubberband(value: number | boolean | Vector2 = 0): Vector2 {\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND)\n      case false:\n        return ensureVector(0)\n      default:\n        return ensureVector(value)\n    }\n  },\n\n  enabled(value = true) {\n    return value\n  },\n\n  triggerAllEvents(value = false) {\n    return value\n  },\n\n  initial(value = 0) {\n    if (typeof value === 'function') return value\n    return ensureVector(value)\n  },\n}\n\nconst InternalCoordinatesOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n  axis: true,\n  lockDirection(value = false) {\n    return value\n  },\n  bounds(value: Bounds | ((state?: State) => Bounds) = {}) {\n    if (typeof value === 'function')\n      return (state?: State) => InternalCoordinatesOptionsNormalizers.bounds(value(state))\n\n    const { left = -Infinity, right = Infinity, top = -Infinity, bottom = Infinity } = value\n\n    return [\n      [left, right],\n      [top, bottom],\n    ]\n  },\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement\n\nconst InternalGenericOptionsNormalizers = {\n  enabled(value = true) {\n    return value\n  },\n  domTarget: true,\n  window(value = isBrowser ? window : undefined) {\n    return value\n  },\n  eventOptions({ passive = true, capture = false } = {}) {\n    return { passive, capture }\n  },\n}\n\nconst InternalDistanceAngleOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n\n  bounds(_value: undefined, _key: string, { distanceBounds = {}, angleBounds = {} }: any) {\n    const _distanceBounds = (state?: State) => {\n      const D = assignDefault(valueFn(distanceBounds, state), { min: -Infinity, max: Infinity })\n      return [D.min, D.max]\n    }\n\n    const _angleBounds = (state?: State) => {\n      const A = assignDefault(valueFn(angleBounds, state), { min: -Infinity, max: Infinity })\n      return [A.min, A.max]\n    }\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function')\n      return [_distanceBounds(), _angleBounds()]\n\n    return (state?: State) => [_distanceBounds(state), _angleBounds(state)]\n  },\n}\n\nconst InternalDragOptionsNormalizers = {\n  ...InternalCoordinatesOptionsNormalizers,\n\n  threshold(\n    this: any,\n    v: number | Vector2 | undefined,\n    _k: string,\n    { filterTaps = false, lockDirection = false, axis = undefined }: any\n  ) {\n    const A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0) as Vector2\n    this.filterTaps = filterTaps || A[0] + A[1] > 0\n    return A\n  },\n\n  swipeVelocity(v: number | Vector2 = DEFAULT_SWIPE_VELOCITY) {\n    return ensureVector(v)\n  },\n  swipeDistance(v: number | Vector2 = DEFAULT_SWIPE_DISTANCE) {\n    return ensureVector(v)\n  },\n\n  delay(value: number | boolean = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY\n      case false:\n        return 0\n      default:\n        return value\n    }\n  },\n}\n\nexport function getInternalGenericOptions(config: GenericOptions = {}): InternalGenericOptions {\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith<GenericOptions, InternalGenericOptions>(config, InternalGenericOptionsNormalizers)\n}\n\nexport function getInternalGestureOptions<T extends StateKey>(\n  config: GestureOptions<T> = {}\n): InternalGestureOptions<T> {\n  return resolveWith<GestureOptions<T>, InternalGestureOptions<T>>(config, InternalGestureOptionsNormalizers)\n}\n\nexport function getInternalCoordinatesOptions<T extends CoordinatesKey>(\n  config: CoordinatesConfig<T> = {}\n): InternalCoordinatesOptions<T> {\n  return resolveWith<CoordinatesConfig<T>, InternalCoordinatesOptions<T>>(config, InternalCoordinatesOptionsNormalizers)\n}\n\nexport function getInternalDistanceAngleOptions<T extends DistanceAngleKey>(\n  config: DistanceAngleConfig<T> = {}\n): InternalDistanceAngleOptions<T> {\n  return resolveWith<DistanceAngleConfig<T>, InternalDistanceAngleOptions<T>>(\n    config,\n    InternalDistanceAngleOptionsNormalizers\n  )\n}\n\nexport function getInternalDragOptions(config: DragConfig = {}): InternalDragOptions {\n  return resolveWith<DragConfig, InternalDragOptions>(config, InternalDragOptionsNormalizers)\n}\n","import {\n  InternalConfig,\n  UseMoveConfig,\n  UseHoverConfig,\n  UseDragConfig,\n  UsePinchConfig,\n  UseScrollConfig,\n  UseWheelConfig,\n} from '../types'\n\nimport {\n  getInternalGenericOptions,\n  getInternalCoordinatesOptions,\n  getInternalDragOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\n\nimport { UseGestureConfig } from '../types'\n\nexport function _buildMoveConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseMoveConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.move = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildHoverConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseHoverConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.hover = { enabled: true, ...rest }\n  return opts\n}\n\nexport function _buildDragConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseDragConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.drag = getInternalDragOptions(rest)\n  return opts\n}\n\nexport function _buildPinchConfig({ domTarget, eventOptions, window, enabled, ...rest }: UsePinchConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.pinch = getInternalDistanceAngleOptions(rest)\n  return opts\n}\n\nexport function _buildScrollConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseScrollConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.scroll = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildWheelConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseWheelConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.wheel = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function buildComplexConfig(config: UseGestureConfig = {}, actions: Set<string> = new Set()) {\n  const { drag, wheel, move, scroll, pinch, hover, eventOptions, window, domTarget, enabled } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions({ eventOptions, window, domTarget, enabled })\n\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag)\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move)\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  if (actions.has('onHover')) mergedConfig.hover = { enabled: true, ...hover }\n\n  return mergedConfig\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2, DragState } from '../types'\n\nfunction getInitial<T>(mixed: T): T & CommonGestureState {\n  return {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [\n      [-Infinity, Infinity],\n      [-Infinity, Infinity],\n    ],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n    ...mixed,\n  }\n}\n\nexport function getInitialState(): State {\n  const shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n  }\n\n  const drag = getInitial<DragState & Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n    _isTap: true,\n    _delayedEvent: false,\n    _pointerId: undefined,\n    tap: false,\n    swipe: [0, 0],\n  })\n\n  const pinch = getInitial<DistanceAngle>({\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    // @ts-ignore origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0,\n  })\n\n  const wheel = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const move = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const scroll = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  return { shared, drag, pinch, wheel, move, scroll }\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  IngKey,\n  InternalConfig,\n  GestureKey,\n  GestureState,\n  EventTypes,\n  PartialGestureState,\n  Vector2,\n  FullGestureState,\n  RecognizerClass,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { rubberbandIfOutOfBounds } from '../utils/rubberband'\nimport { subV, addV, sign } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\nexport const RecognizersMap = new Map<GestureKey, RecognizerClass>()\n\n/**\n * @private\n * Recognizer abstract class.\n */\nexport default abstract class Recognizer<T extends StateKey = StateKey> {\n  abstract readonly ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n  abstract readonly stateKey: T\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(readonly controller: Controller, readonly args: any[] = []) {}\n\n  // Returns the gesture config\n  get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  // Convenience method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Convenience method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  protected abstract getKinematics(values: Vector2, event: UIEvent): PartialGestureState<T>\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n  protected abstract mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'>\n\n  public abstract addBindings(bindings: any): void\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2): PartialGestureState<T> {\n    const { initial, bounds, rubberband, threshold: T } = this.config\n\n    const { _bounds, _initial, _active, _intentional: wasIntentional, lastOffset, movement: prevMovement } = this.state\n    const M = this.getInternalMovement(values, this.state)\n\n    const i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], T[0]) : wasIntentional[0]\n    const i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], T[1]) : wasIntentional[1]\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], M)\n    if (intentionalityCheck._blocked) {\n      return { ...intentionalityCheck, _movement: M, delta: [0, 0] }\n    }\n\n    const _intentional = intentionalityCheck._intentional!\n    const _movement = M\n\n    let __cachedBounds\n    let __cachedInitial\n\n    if (_intentional[0] !== false && wasIntentional[0] === false) {\n      __cachedInitial = valueFn(initial, this.state)\n      __cachedBounds = valueFn(bounds, this.state)\n      _initial[0] = __cachedInitial[0]\n      _bounds[0] = __cachedBounds[0]\n    }\n    if (_intentional[1] !== false && wasIntentional[1] === false) {\n      __cachedInitial = __cachedInitial ?? valueFn(initial, this.state)\n      __cachedBounds = __cachedBounds ?? valueFn(bounds, this.state)\n      _initial[1] = __cachedInitial[1]\n      _bounds[1] = __cachedBounds[1]\n    }\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement: Vector2 = [\n      _intentional[0] !== false ? M[0] - _intentional[0] : _initial[0],\n      _intentional[1] !== false ? M[1] - _intentional[1] : _initial[1],\n    ]\n\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband)\n\n    return {\n      ...intentionalityCheck,\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial,\n      _movement,\n      movement,\n      values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n  }\n\n  /**\n   * Fires the gesture handler\n   */\n  protected fireGestureHandler = (forceFlag: boolean = false): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't fire the handler.\n    if (!forceFlag && !this.state.intentional && !this.config.triggerAllEvents) return null\n\n    if (this.state.intentional) {\n      const prev_active = this.state.active\n      const next_active = this.state._active\n\n      this.state.active = next_active\n      this.state.first = next_active && !prev_active\n      this.state.last = prev_active && !next_active\n\n      this.controller.state.shared[this.ingKey] = next_active // Sets dragging, pinching, etc. to the gesture active state\n    }\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n    } as FullGestureState<T>\n\n    // @ts-ignore\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    // Cleans the gesture when the gesture is no longer active.\n    if (!this.state._active) this.clean()\n\n    return state\n  }\n}\n\n//--------------------------------------------\n\nfunction getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold\n  } else {\n    return false\n  }\n}\n\nfunction computeRubberband(bounds: [Vector2, Vector2], [Vx, Vy]: Vector2, [Rx, Ry]: Vector2): Vector2 {\n  const [[X1, X2], [Y1, Y2]] = bounds\n\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)]\n}\n\n/**\n * Returns a generic, common payload for all gestures from an event.\n */\nexport function getGenericPayload<T extends StateKey>(\n  { state, args }: Recognizer<T>,\n  event: EventTypes[T],\n  isStartEvent?: boolean\n) {\n  const { timeStamp, type: _lastEventType } = event\n  const previous = state.values\n  const elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime!\n  return { _lastEventType, event, timeStamp, elapsedTime, args, previous }\n}\n\n/**\n * Returns the reinitialized start state for the gesture.\n * Should be common to all gestures.\n */\nexport function getStartGestureState<T extends StateKey>(\n  recognizer: Recognizer<T>,\n  values: Vector2,\n  event: EventTypes[T]\n) {\n  const offset = recognizer.state.offset\n  const startTime = event.timeStamp\n\n  return {\n    ...getInitialState()[recognizer.stateKey],\n    _active: true,\n    values,\n    initial: values,\n    offset,\n    lastOffset: offset,\n    startTime,\n  }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n  RecognizerClass,\n} from './types'\nimport { getInitialState } from './utils/state'\nimport { chainFns } from './utils/utils'\n\nfunction partial(func: Fn, state: any) {\n  return function (event: any, ...args: any) {\n    // @ts-ignore\n    return func.call(this, { ...state, event }, ...args)\n  }\n}\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n */\nexport default class Controller {\n  public nativeRefs!: any\n  public config!: InternalConfig\n  public handlers!: InternalHandlers\n  public state: State // state for all gestures\n  public timeouts: { [stateKey in StateKey]?: number } // tracks timeouts of debounced gestures\n  public domListeners: [string, Fn][] // when config.domTarget is set, we attach events directly to the dom\n  public windowListeners: { [stateKey in StateKey]?: [string, Function][] } // keeps track of window listeners added by gestures (drag only at the moment)\n\n  constructor(private classes: Set<RecognizerClass>) {\n    this.state = getInitialState()\n    this.timeouts = {}\n    this.domListeners = []\n    this.windowListeners = {}\n  }\n\n  public bind = (...args: any[]) => {\n    const bindings: { [key: string]: Function[] } = {}\n\n    for (let RecognizerClass of this.classes) new RecognizerClass(this, args).addBindings(bindings)\n\n    // we also add event bindings for native handlers\n    for (let [event, handler] of Object.entries(this.nativeRefs))\n      addBindings(bindings, event, partial(handler, { ...this.state.shared, args }))\n\n    if (this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(this, bindings)\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(this, bindings)\n    }\n  }\n\n  public effect = () => {\n    if (this.config.domTarget) this.bind()\n    return this.clean\n  }\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    const domTarget = getDomTargetFromConfig(this.config)\n    const { eventOptions } = this.config\n    if (domTarget) removeListeners(domTarget, takeAll(this.domListeners), eventOptions)\n    Object.values(this.timeouts).forEach(clearTimeout)\n    clearAllWindowListeners(this)\n  }\n}\n\nexport function clearAllWindowListeners(controller: Controller) {\n  const {\n    config: { window: el, eventOptions },\n    windowListeners,\n  } = controller\n  if (!el) return\n\n  for (let stateKey in windowListeners) {\n    const handlers = windowListeners[stateKey as StateKey]\n    removeListeners(el, handlers, eventOptions)\n  }\n\n  controller.windowListeners = {}\n}\n\nexport function clearWindowListeners({ config, windowListeners }: Controller, stateKey: StateKey) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], config.eventOptions)\n  delete windowListeners[stateKey]\n}\n\nexport function updateWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  listeners: [string, Fn][] = []\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], config.eventOptions)\n  addListeners(config.window, (windowListeners[stateKey] = listeners), config.eventOptions)\n}\n\nfunction updateDomListeners({ config, domListeners }: Controller, bindings: { [key: string]: Function[] }) {\n  const domTarget = getDomTargetFromConfig(config)\n  if (!domTarget) throw new Error('domTarget must be defined')\n  const { eventOptions } = config\n\n  removeListeners(domTarget, takeAll(domListeners), eventOptions)\n\n  for (let [key, fns] of Object.entries(bindings)) {\n    const name = key.slice(2).toLowerCase()\n    domListeners.push([name, chainFns(...fns)])\n  }\n\n  addListeners(domTarget, domListeners, eventOptions)\n}\n\nfunction getPropsListener({ config }: Controller, bindings: { [key: string]: Function[] }) {\n  const props: ReactEventHandlers = {}\n  const captureString = config.eventOptions.capture ? 'Capture' : ''\n  for (let [event, fns] of Object.entries(bindings)) {\n    const fnsArray = Array.isArray(fns) ? fns : [fns]\n    const key = (event + captureString) as ReactEventHandlerKey\n    props[key] = chainFns(...(fnsArray as Fn[]))\n  }\n  return props\n}\n\nfunction takeAll<T>(array: Array<T> = []) {\n  return array.splice(0, array.length)\n}\n\nfunction getDomTargetFromConfig({ domTarget }: InternalConfig) {\n  return domTarget && 'value' in domTarget ? domTarget.value : domTarget\n}\n\n/**\n * bindings is an object which keys match ReactEventHandlerKeys.\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n * that key.\n */\nexport function addBindings(bindings: any, name: string, fn: Fn): void {\n  if (!bindings[name]) bindings[name] = []\n  bindings[name]!.push(fn)\n}\n\nfunction addListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.addEventListener(eventName, eventHandler, options)\n  }\n}\n\nfunction removeListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.removeEventListener(eventName, eventHandler, options)\n  }\n}\n","import { onMounted } from 'vue-demi'\n\n// import * as React from '../utils/react';\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  GenericOptions,\n  RecognizerClass,\n  NativeHandlers,\n} from '../types'\n\n/**\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param handlers\n * @param classes\n * @param config\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  config: InternalConfig,\n  nativeHandlers: Partial<NativeHandlers> = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const classes = resolveClasses(handlers)\n\n  // const controller = React.useMemo(() => new Controller(classes), []);\n  const controller = new Controller(classes)\n  controller!.config = config\n  controller!.handlers = handlers\n  controller!.nativeRefs = nativeHandlers\n\n  // React.useEffect(controller.effect, []);\n  // console.log(controller.effect);//\n  onMounted(controller.effect)\n\n  // @ts-ignore\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget\n  // @ts-ignore\n  return controller.bind\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      `Deprecation notice: When the \\`domTarget\\` option is specified, you don't need to write \\`useEffect(bind, [bind])\\` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when \\`domTarget\\` is provided, therefore your code will break if you try to call \\`useEffect\\`.`\n    )\n  }\n}\n\nfunction resolveClasses(internalHandlers: Partial<InternalHandlers>) {\n  const classes = new Set<RecognizerClass>()\n\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag')!)\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel')!)\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll')!)\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move')!)\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch')!)\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover')!)\n\n  return classes\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return { _intentional, axis: this.state.axis } as PartialGestureState<T>\n    }\n    const [absX, absY] = _movement.map(Math.abs)\n    const axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n    if (!this.config.axis && !this.config.lockDirection) return { _intentional, _blocked: false, axis } as any\n    if (!axis) return { _intentional: [false, false], _blocked: false, axis } as any\n    if (!!this.config.axis && axis !== this.config.axis) return { _intentional, _blocked: true, axis } as any\n    _intentional![axis === 'x' ? 1 : 0] = false\n    return { _intentional, _blocked: false, axis } as any\n  }\n\n  getKinematics(values: Vector2, event: UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    if (!state._blocked) {\n      const dt = event.timeStamp - this.state.timeStamp!\n      Object.assign(state, calculateAllKinematics(state.movement!, state.delta!, dt))\n    }\n    return state\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { xy: state.values, vxvy: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n","import { Vector2, WebKitGestureEvent, DomEvents } from '../types'\n\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport function supportsTouchEvents(): boolean {\n  return typeof window !== 'undefined' && window.ontouchstart === null\n}\n\nfunction getTouchEvents(event: DomEvents) {\n  if ('touches' in event) {\n    const { targetTouches, changedTouches } = event\n    return targetTouches.length > 0 ? targetTouches : changedTouches\n  }\n  return null\n}\n\nexport function getGenericEventData(event: DomEvents) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const touchEvents = getTouchEvents(event)\n  const touches = (touchEvents && touchEvents.length) || 0\n  const down = touches > 0 || buttons > 0\n\n  const { shiftKey, altKey, metaKey, ctrlKey } = event as any // TODO check if this might create some overrides?\n  return { touches, down, buttons, shiftKey, altKey, metaKey, ctrlKey }\n}\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(event: TouchEvent | PointerEvent): Vector2 {\n  const touchEvents = getTouchEvents(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : event\n  return [clientX, clientY]\n}\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: UIEvent): Vector2 {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]\n}\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: WheelEvent): Vector2 {\n  const { deltaX, deltaY } = event\n  //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n  return [deltaX, deltaY]\n}\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent): Vector2 {\n  return [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation]\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventData(event: TouchEvent) {\n  const { targetTouches } = event\n  const A = targetTouches[0],\n    B = targetTouches[1]\n\n  const dx = B.clientX - A.clientX\n  const dy = B.clientY - A.clientY\n  const cx = (B.clientX + A.clientX) / 2\n  const cy = (B.clientY + A.clientY) / 2\n\n  const e: any = 'nativeEvent' in event ? event['nativeEvent'] : event //TODO: why never?\n\n  const distance = Math.hypot(dx, dy)\n  const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n\n  const values: Vector2 = [distance, angle]\n  const origin: Vector2 = [cx, cy]\n\n  return { values, origin }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { calculateDistance, sign } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, updateWindowListeners, clearWindowListeners } from '../Controller'\n\nexport const TAP_DISTANCE_THRESHOLD = 3\nexport const SWIPE_MAX_ELAPSED_TIME = 220\n\nexport class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  readonly ingKey = 'dragging'\n  readonly stateKey = 'drag'\n\n  /**\n   * TODO add back when setPointerCapture is widely wupported\n   * https://caniuse.com/#search=setPointerCapture\n   * private setPointers = (event: UseGestureEvent<PointerEvent>) => {\n   *   const { currentTarget, pointerId } = event\n   *   if (currentTarget) currentTarget.setPointerCapture(pointerId)\n   *   this.updateGestureState({ currentTarget, pointerId })\n   * }\n\n   * private removePointers = () => {\n   *   const { currentTarget, pointerId } = this.state\n   *   if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId)\n   * }\n   */\n\n  onDragStart = (event: PointerEvent): void => {\n    if (!this.enabled || this.state._active) return\n\n    /**\n     * TODO add back when setPointerCapture is widely supported\n     * this.setPointers(event as PointerEvent)\n     */\n\n    updateWindowListeners(this.controller, this.stateKey, [\n      ['pointermove', this.onDragChange],\n      ['pointerup', this.onDragEnd],\n      ['pointercancel', this.onDragEnd],\n    ])\n\n    // We set the state pointerId to the event.pointerId so we can make sure\n    // that we lock the drag to the event initiating the gesture\n    this.updateGestureState({ _pointerId: event.pointerId })\n\n    if (this.config.delay > 0) {\n      this.state._delayedEvent = true\n      // If it's a React SyntheticEvent we need to persist it so that we can use it async\n      // if ('persist' in event && typeof event.persist === 'function') event.persist();\n      // this.setTimeout(this.startDrag.bind(this), this.config.delay, event);\n    } else {\n      this.startDrag(event)\n    }\n  }\n\n  startDrag(event: PointerEvent) {\n    const values = getPointerEventValues(event)\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerId: event.pointerId,\n      cancel: this.onCancel,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: PointerEvent): void => {\n    // If the gesture was canceled don't respond to the event.\n    if (this.state.canceled) return\n\n    // If the event pointerId doesn't match the initiating pointerId\n    // don't respond to the event.\n    if (event.pointerId !== this.state._pointerId) return\n\n    // If the gesture isn't active then respond to the event only if\n    // it's been delayed via the `delay` option, in which case start\n    // the gesture immediately.\n    if (!this.state._active) {\n      if (this.state._delayedEvent) {\n        this.clearTimeout()\n        this.startDrag(event)\n      }\n      return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    // If the event doesn't have any button / touches left we should cancel\n    // the gesture. This may happen if the drag release happens outside the browser\n    // window.\n    if (!genericEventData.down) {\n      this.onDragEnd(event)\n      return\n    }\n\n    this.updateSharedState(genericEventData)\n    const values = getPointerEventValues(event)\n\n    const kinematics = this.getKinematics(values, event)\n    const genericPayload = getGenericPayload(this, event)\n\n    // This verifies if the drag can be assimilated to a tap by checking\n    // if the real distance of the drag (ie not accounting for the threshold) is\n    // greater than the TAP_DISTANCE_THRESHOLD.\n    let { _isTap } = this.state\n    const realDistance = calculateDistance(kinematics._movement!)\n    if (_isTap && realDistance >= TAP_DISTANCE_THRESHOLD) _isTap = false\n\n    this.updateGestureState({ ...genericPayload, ...kinematics, _isTap })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: PointerEvent): void => {\n    // If the event pointerId doesn't match the initiating pointerId\n    // don't respond to the event.\n    if (event.pointerId !== this.state._pointerId) return\n\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n\n    const tap = this.state._isTap\n    const [vx, vy] = this.state.velocities\n    const [mx, my] = this.state.movement\n    const [ix, iy] = this.state._intentional\n    const [svx, svy] = this.config.swipeVelocity\n    const [sx, sy] = this.config.swipeDistance\n\n    const endState = {\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    }\n\n    const swipe: [number, number] = [0, 0]\n\n    if (endState.elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy)\n    }\n\n    this.updateGestureState({ ...endState, tap, swipe })\n    this.fireGestureHandler(tap === true)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._delayedEvent = false // can't remember if this is useful?\n    clearWindowListeners(this.controller, this.stateKey)\n    // TODO add back when setPointerCapture is widely wupported\n    // this.removePointers()\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ canceled: true })\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n\n  onClick = (event: UIEvent): void => {\n    if (!this.state._isTap) event.stopPropagation()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onPointerDown', this.onDragStart)\n    if (this.config.filterTaps) {\n      const handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture'\n      addBindings(bindings, handler, this.onClick)\n    }\n\n    // TODO add back when setPointerCapture is widely wupported\n    // addBindings(bindings, 'onPointerMove', this.onDragChange)\n    // addBindings(bindings, 'onPointerUp', this.onDragEnd)\n    // addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n  }\n}\n","/**\n * Inlined from https://github.com/alexreardon/memoize-one\n */\n\nexport type EqualityFn = (newArgs: any[], lastArgs: any[]) => boolean\n\nexport default function memoizeOne<ResultFn extends (this: any, ...newArgs: any[]) => ReturnType<ResultFn>>(\n  resultFn: ResultFn,\n  isEqual: EqualityFn\n): ResultFn {\n  let lastThis: unknown\n  let lastArgs: unknown[] = []\n  let lastResult: ReturnType<ResultFn>\n  let calledOnce: boolean = false\n\n  function memoized(this: unknown, ...newArgs: unknown[]): ReturnType<ResultFn> {\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult\n    }\n\n    lastResult = resultFn.apply(this, newArgs)\n    calledOnce = true\n    lastThis = this\n    lastArgs = newArgs\n    return lastResult\n  }\n\n  return memoized as ResultFn\n}\n","/**\n * Taken from https://github.com/FormidableLabs/react-fast-compare\n *\n * Dropped comments and ArrayBuffer handling\n */\n\nfunction equal(a: any, b: any): boolean {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false\n\n    let length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      if (length !== b.length) return false\n      for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false\n      return true\n    }\n\n    let it\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!equal(i.value[1], b.get(i.value[0]))) return false\n      return true\n    }\n\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      return true\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf()\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    if (typeof Element !== 'undefined' && a instanceof Element) return false\n\n    for (i = length; i-- !== 0; ) {\n      if (keys[i] === '_owner' && a.$$typeof) continue\n      if (!equal(a[keys[i]], b[keys[i]])) return false\n    }\n    return true\n  }\n\n  // true if both NaN, false otherwise — NaN !== NaN → true\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport default function isEqual(a: any, b: any) {\n  try {\n    return equal(a, b)\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      console.warn('react-fast-compare cannot handle circular refs')\n      return false\n    }\n    throw error\n  }\n}\n","import DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { Vector2, WebKitGestureEvent } from '../types'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventData,\n  getWheelEventValues,\n  supportsGestureEvents,\n  getWebkitGestureEventValues,\n  supportsTouchEvents,\n} from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  readonly ingKey = 'pinching'\n  readonly stateKey = 'pinch'\n\n  private pinchShouldStart = (event: TouchEvent) => {\n    const { touches } = getGenericEventData(event)\n    return this.enabled && touches === 2\n  }\n\n  onPinchStart = (event: TouchEvent) => {\n    if (!this.pinchShouldStart(event)) return\n\n    const { values, origin } = getTwoTouchesEventData(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      // TODO remove after type update\n      // @ts-ignore\n      ...getStartGestureState(this, values, event),\n      // @ts-ignore\n      ...getGenericPayload(this, event, true),\n      cancel: this.onCancel,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: TouchEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin } = getTwoTouchesEventData(event)\n    // @ts-ignore\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      // @ts-ignore\n      ...getGenericPayload(this, event),\n      ...kinematics,\n      origin,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchEnd = (event: TouchEvent): void => {\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      // @ts-ignore\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.state._active = false\n    this.updateGestureState({ canceled: true })\n    this.updateSharedState({ down: false, touches: 0 })\n\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault() // useless\n\n    const values = getWebkitGestureEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      cancel: this.onCancel,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const values = getWebkitGestureEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    event.preventDefault()\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: WheelEvent) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: WheelEvent) => {\n    const [, delta_d] = getWheelEventValues(event)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    const d = prev_d - delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [0, delta_d] as Vector2,\n    }\n  }\n\n  onWheel = (event: WheelEvent): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: WheelEvent): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (event.cancelable) event.preventDefault()\n    else if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      initial: this.state.values,\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: WheelEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && !supportsTouchEvents() && supportsGestureEvents()) {\n      addBindings(bindings, 'gestureStart', this.onGestureStart)\n      addBindings(bindings, 'gestureChange', this.onGestureChange)\n      addBindings(bindings, 'gestureEnd', this.onGestureEnd)\n    } else {\n      addBindings(bindings, 'touchstart', this.onPinchStart)\n      addBindings(bindings, 'touchmove', this.onPinchChange)\n      addBindings(bindings, 'touchend', this.onPinchEnd)\n      addBindings(bindings, 'touchcancel', this.onPinchEnd)\n      addBindings(bindings, 'wheel', this.onWheel)\n    }\n  }\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, sign, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  protected getInternalMovement(values: [number, number?], state: GestureState<T>): Vector2 {\n    const prev_a = state.values[1]\n    // not be defined if ctrl+wheel is used for zoom only\n    let [d, a = prev_a] = values\n\n    let delta_a = a - prev_a\n    let next_turns = state.turns\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a)\n    return subV([d, a - 360 * next_turns], state.initial)\n  }\n\n  getKinematics(values: Vector2, event: UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    const turns = (values[1] - state.movement![1] - this.state.initial[1]) / 360\n    const dt = event.timeStamp - this.state.timeStamp!\n    const kinematics = calculateAllKinematics(state.movement!, state.delta!, dt)\n    return { turns, ...state, ...kinematics }\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { da: state.values, vdva: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n\n/**\n * @param dangle is a small change of variable on \"lifting\" of the circle.\n * It's expected to be small and cannot be greater than 270 or under -270\n */\nexport function fixContinuity(dangle: number) {\n  dangle -= Math.round(dangle / 360) * 360\n  if (dangle > 270) return dangle - 360\n  if (dangle < -270) return dangle + 360\n  return dangle\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  readonly ingKey = 'wheeling'\n  readonly stateKey = 'wheel'\n  debounced = true\n\n  handleEvent = (event: WheelEvent): void => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return\n    if (!this.enabled) return\n\n    this.setTimeout(this.onEnd)\n    this.updateSharedState(getGenericEventData(event))\n\n    const values = addV(getWheelEventValues(event), this.state.values)\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event),\n        ...getGenericPayload(this, event, true),\n        initial: this.state.values,\n      })\n\n      const movement = this.getMovement(values)\n      const geometry = calculateAllGeometry(movement.delta!)\n\n      this.updateGestureState(movement)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    const movement = this.getMovement(this.state.values)\n    this.updateGestureState(movement)\n    this.updateGestureState({ _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onWheel', this.handleEvent)\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  readonly ingKey = 'moving'\n  readonly stateKey = 'move'\n\n  debounced = true\n\n  onMove = (event: PointerEvent): void => {\n    if (!this.enabled) return\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event)\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    const values = this.state.values\n    this.updateGestureState(this.getMovement(values))\n    this.updateGestureState({ velocities: [0, 0], velocity: 0, _active: false })\n    this.fireGestureHandler()\n  }\n\n  onPointerEnter = (event: PointerEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const values = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...getGenericPayload(this, event, true),\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: PointerEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n    if (!this.controller.config.hover!.enabled) return\n\n    const values = getPointerEventValues(event)\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...getGenericPayload(this, event),\n      values,\n      active: false,\n    }\n\n    this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n  }\n\n  addBindings(bindings: any): void {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove)\n    }\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter)\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave)\n    }\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  readonly ingKey = 'scrolling'\n  readonly stateKey = 'scroll'\n  debounced = true\n\n  handleEvent = (event: UIEvent): void => {\n    if (!this.enabled) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const values = getScrollEventValues(event)\n    this.updateSharedState(getGenericEventData(event))\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event),\n        ...getGenericPayload(this, event, true),\n        initial: this.state.values,\n      })\n\n      const movementDetection = this.getMovement(values)\n      const geometry = calculateAllGeometry(movementDetection.delta!)\n\n      this.updateGestureState(movementDetection)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onScroll', this.handleEvent)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport { buildComplexConfig } from './buildConfig'\nimport {\n  InternalConfig,\n  InternalHandlers,\n  UserHandlers,\n  UseGestureConfig,\n  Handlers,\n  EventTypes,\n  AnyGestureEventTypes,\n} from '../types'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\n\nexport function wrapStart(fn: Function) {\n  return function (this: any, { first }: any) {\n    if (first) fn.apply(this, arguments)\n  }\n}\n\nexport function wrapEnd(fn: Function) {\n  return function (this: any, { last }: any) {\n    if (last) fn.apply(this, arguments)\n  }\n}\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/\n\nfunction sortHandlers(handlers: object) {\n  const native: any = {}\n  const handle: any = {}\n  const actions = new Set()\n\n  for (let key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch)\n      handle[key] = (handlers as any)[key]\n    } else {\n      native[key] = (handlers as any)[key]\n    }\n  }\n\n  return [handle, native, actions]\n}\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<T extends AnyGestureEventTypes = EventTypes>(\n  _handlers: Handlers<T>,\n  config: UseGestureConfig = {}\n) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(_handlers)\n\n  RecognizersMap.set('drag', DragRecognizer)\n  RecognizersMap.set('hover', MoveRecognizer)\n  RecognizersMap.set('move', MoveRecognizer)\n  RecognizersMap.set('pinch', PinchRecognizer)\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  RecognizersMap.set('wheel', WheelRecognizer)\n\n  const mergedConfig: InternalConfig = buildComplexConfig(config, actions)\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag')\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel')\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll')\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove')\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch')\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover\n\n  return useRecognizers<UseGestureConfig>(internalHandlers, mergedConfig, nativeHandlers)\n}\n\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\ntype HandlerKey = 'onDrag' | 'onPinch' | 'onWheel' | 'onMove' | 'onScroll' | 'onHover'\nfunction includeStartEndHandlers(handlers: Partial<UserHandlers>, handlerKey: HandlerKey) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n","export interface SpringConfig {\n  /**\n   * Mass of the spring\n   */\n  mass?: number\n  /**\n   * Spring energetic load. Also called stiffness\n   */\n  tension: number\n  /**\n   * Spring resistance.\n   */\n  friction: number\n  /**\n   * The higher the precision, the more smooth and slow to compute the animation\n   * will be. By default 0.01 is a good value, but can be decreased to 0.1 in\n   * some scenarios for performance.\n   */\n  precision?: number\n}\n\nexport const noWobble: SpringConfig = {\n  mass: 1,\n  tension: 170,\n  friction: 26,\n  precision: 0.01,\n} // the default, if nothing provided\nexport const gentle: SpringConfig = {\n  mass: 1,\n  tension: 120,\n  friction: 14,\n  precision: 0.01,\n}\nexport const wobbly: SpringConfig = {\n  mass: 1,\n  tension: 180,\n  friction: 12,\n  precision: 0.01,\n}\nexport const stiff: SpringConfig = {\n  mass: 1,\n  tension: 210,\n  friction: 20,\n  precision: 0.01,\n}\n\nexport const presets = { noWobble, gentle, wobbly, stiff }\n","import { SpringConfig } from './presets'\n\nexport const isClient = typeof window !== 'undefined'\n\nexport const raf = isClient ? window.requestAnimationFrame.bind(window) : () => {}\nexport const cancelRaf = isClient ? window.cancelAnimationFrame.bind(window) : () => {}\n\nexport const now = typeof performance !== 'undefined' ? performance.now.bind(performance) : Date.now.bind(Date)\n\nexport const isArray = Array.isArray.bind(Array)\n\nexport const isObject = (value: any): value is object => value != null && typeof value === 'object'\nexport const isFunction = (value: unknown): value is Function => typeof value === 'function'\n\n// stepper is used a lot. Saves allocation to return the same array wrapper.\n// This is fine and danger-free against mutations because the callsite\n// immediately destructures it and gets the numbers inside without passing the\n// array reference around.\nconst reusedTuple: [number, number] = [0, 0]\nexport function stepper(\n  secondPerFrame: number,\n  x: number,\n  v: number,\n  destX: number,\n  spring: SpringConfig\n): [number, number] {\n  // Spring stiffness, in kg / s^2\n\n  // for animations, destX is really spring length (spring at rest). initial\n  // position is considered as the stretched/compressed position of a spring\n  const Fspring = -spring.tension * (x - destX)\n  // Damping, in kg / s\n  const Fdamper = -spring.friction * v\n\n  const a = (Fspring + Fdamper) / (spring.mass || 1)\n\n  const newV = v + a * secondPerFrame\n  const newX = x + newV * secondPerFrame\n\n  const precision = spring.precision || 0.01\n\n  if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {\n    reusedTuple[0] = destX\n    reusedTuple[1] = 0\n    return reusedTuple\n  }\n\n  reusedTuple[0] = newX\n  reusedTuple[1] = newV\n\n  return reusedTuple\n}\n","import { computed, onMounted, onUnmounted, reactive, Ref, ref, watch, toRefs } from 'vue-demi'\nimport { SpringConfig, noWobble } from './presets'\nimport { raf, cancelRaf, now, isArray, stepper, isFunction } from './utils'\n\nconst msPerFrame = 1000 / 60\n\ntype NumericalValues = Record<string, number> | number[]\nexport type SpringValue = NumericalValues\n\nfunction defineInitialValues<T extends NumericalValues>(values: T, velocities: T | null): [T, T] {\n  const newValues = (isArray(values) ? [] : {}) as T\n  const newVelocities = (isArray(values) ? [] : {}) as T\n\n  for (const key in values) {\n    newValues[key] = values[key]\n    // @ts-ignore\n    newVelocities[key] = velocities ? velocities[key] : 0\n  }\n\n  return [newValues, newVelocities]\n}\n\nexport interface SpringObject<T extends SpringValue> {\n  values: T\n}\n\nconst noop = () => {}\n\nexport function useSpring<T extends SpringValue>(\n  initialValue: T | Ref<T>,\n  // TODO: could change\n  springConfiguration?: SpringConfig,\n  options: {\n    onRest?: () => any\n  } = {}\n): T {\n  const spring = springConfiguration || noWobble\n\n  const onRest = options.onRest || noop\n\n  // hold a ref to real values so we can change them\n  // @ts-ignore\n  const realValues = isFunction(initialValue) ? ref(initialValue()) : ref(initialValue)\n\n  let wasAnimating = false\n  let prevTime = 0\n  let accumulatedTime = 0\n\n  watch(\n    realValues,\n    (_current, _old) => {\n      if (!wasAnimating) {\n        prevTime = now()\n        accumulatedTime = 0\n        animate()\n      }\n    },\n    { deep: true }\n  )\n\n  const current = defineInitialValues(realValues.value, null)\n\n  const currentValues = ref(current[0])\n  const currentVelocities = ref(current[1])\n\n  // only done to correctly infer types, they're overridden in mounted\n  let idealValues = current[0]\n  let idealVelocities = current[1]\n\n  onMounted(() => {\n    prevTime = now()\n    accumulatedTime = 0\n\n    const ideal = defineInitialValues(currentValues.value, currentVelocities.value)\n\n    idealValues = ideal[0]\n    idealVelocities = ideal[1]\n\n    animate()\n  })\n\n  let animationId: number | void | undefined | null\n  // TODO: also cancel when a new value comes\n  onUnmounted(() => {\n    if (animationId) {\n      cancelRaf(animationId)\n    }\n  })\n\n  function animate() {\n    animationId = raf(() => {\n      if (shouldStopAnimation(currentValues.value, realValues.value, currentVelocities.value)) {\n        // TODO: emit\n        if (wasAnimating) onRest()\n\n        // reset everything for next animation\n        animationId = null\n        wasAnimating = false\n        return\n      }\n\n      // TODO: emit\n      // if (!wasAnimating) this.$emit('motion-start')\n      wasAnimating = true\n\n      // get time from last frame\n      const currentTime = now()\n      const timeDelta = currentTime - prevTime\n      prevTime = currentTime\n      accumulatedTime += timeDelta\n\n      // more than 10 frames? probably switched browser tab. Restart\n      if (accumulatedTime > msPerFrame * 10) {\n        accumulatedTime = 0\n      }\n\n      if (accumulatedTime === 0) {\n        // no need to cancel animationID here; shouldn't have any in flight\n        animationId = null\n        // TODO: emit\n        // this.$emit('motion-restart')\n        return animate()\n      }\n\n      const currentFrameCompletion =\n        (accumulatedTime - Math.floor(accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame\n      const framesToCatchUp = Math.floor(accumulatedTime / msPerFrame)\n\n      animateValues(\n        framesToCatchUp,\n        currentFrameCompletion,\n        spring,\n        realValues.value,\n        currentValues.value,\n        currentVelocities.value,\n        idealValues,\n        idealVelocities\n      )\n\n      // out of the update loop\n      animationId = null\n      // the amount we're looped over above\n      accumulatedTime -= framesToCatchUp * msPerFrame\n\n      // keep going!\n      animate()\n    })\n  }\n\n  const modifiableValues = (isArray(realValues.value) ? [] : {}) as T\n  for (const key in realValues.value) {\n    // @ts-ignore\n    modifiableValues[key] = computed({\n      // @ts-ignore\n      get: () => currentValues.value[key],\n      // @ts-ignore\n      set: (v) => (realValues.value[key] = v),\n    })\n  }\n\n  if (isFunction(initialValue)) {\n    // @ts-ignore\n    const values = toRefs(reactive(modifiableValues)) as any\n\n    const update = (rawValuesObject: any) => {\n      const keys = Object.keys(rawValuesObject)\n      keys.forEach((key) => {\n        if (!(key in values)) return\n        values[key].value = rawValuesObject[key]\n        if ('config' in rawValuesObject) Object.assign(spring, { config: rawValuesObject.config })\n        if ('immediate' in rawValuesObject) Object.assign(spring, { immediate: rawValuesObject.immediate })\n      })\n    }\n\n    // @ts-ignore\n    return [values as T, update as any]\n  }\n\n  return reactive(modifiableValues) as T\n}\n\nfunction shouldStopAnimation(currentValues: SpringValue, values: SpringValue, currentVelocities: NumericalValues) {\n  for (const key in values) {\n    // istanbul ignore if\n    // if (!Object.prototype.hasOwnProperty.call(values, key)) continue\n\n    // Something is still moving\n    if (currentVelocities[key as keyof NumericalValues] !== 0) return false\n\n    // Something hasn't reached its destination\n    // stepper will have already taken care of rounding precision errors, so\n    // won't have such thing as 0.9999 != 1\n    if (currentValues[key as keyof SpringValue] !== values[key as keyof SpringValue]) return false\n  }\n\n  return true\n}\n\nfunction animateValues(\n  framesToCatchUp: number,\n  currentFrameCompletion: number,\n  spring: SpringConfig,\n  realValues: SpringValue,\n  currentValues: SpringValue,\n  currentVelocities: SpringValue,\n  idealValues: SpringValue,\n  idealVelocities: SpringValue\n) {\n  for (const key in realValues) {\n    // istanbul ignore if\n    // if (!Object.prototype.hasOwnProperty.call(realValues, key)) continue\n\n    let newIdealValue = idealValues[key as keyof NumericalValues] as number\n    let newIdealVelocity = idealVelocities[key as keyof NumericalValues] as number\n    const value = realValues[key as keyof NumericalValues] as number\n\n    // iterate as if the animation took place\n    for (let i = 0; i < framesToCatchUp; i++) {\n      ;[newIdealValue, newIdealVelocity] = stepper(msPerFrame / 1000, newIdealValue, newIdealVelocity, value, spring)\n    }\n\n    const [nextIdealValue, nextIdealVelocity] = stepper(\n      msPerFrame / 1000,\n      newIdealValue,\n      newIdealVelocity,\n      value,\n      spring\n    )\n\n    // @ts-ignore\n    currentValues[key] = newIdealValue + (nextIdealValue - newIdealValue) * currentFrameCompletion\n    // @ts-ignore\n    currentVelocities[key] = newIdealVelocity + (nextIdealVelocity - newIdealVelocity) * currentFrameCompletion\n    // @ts-ignore\n    idealValues[key] = newIdealValue\n    // @ts-ignore\n    idealVelocities[key] = newIdealVelocity\n  }\n}\n","import { UseDragConfig, Handler, EventTypes } from '../types'\nimport { _buildDragConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { ref } from 'vue-demi'\n\n/**\n * Drag hook.\n *\n * @param handler - the function fired every time the drag gesture updates\n * @param [config={}] - the config object including generic options and drag options\n */\nexport function useDrag<K = EventTypes['drag']>(handler: Handler<'drag', K>, config: UseDragConfig | {} = {}) {\n  RecognizersMap.set('drag', DragRecognizer)\n  const buildDragConfig = ref<any>()\n  if (!buildDragConfig.value) {\n    buildDragConfig.value = memoize(_buildDragConfig, isEqual)\n  }\n  return useRecognizers<UseDragConfig>({ drag: handler }, buildDragConfig.value(config))\n}\n","import { Handler, UseHoverConfig, EventTypes } from '../types'\nimport { _buildHoverConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { ref } from 'vue-demi'\n\n/**\n * Hover hook.\n *\n * @param handler - the function fired every time the hover gesture updates\n * @param [config={}] - the config object including generic options and hover options\n */\nexport function useHover<K = EventTypes['hover']>(handler: Handler<'hover', K>, config: UseHoverConfig | {} = {}) {\n  RecognizersMap.set('hover', MoveRecognizer)\n  const buildHoverConfig = ref<any>()\n  if (!buildHoverConfig.value) {\n    buildHoverConfig.value = memoize(_buildHoverConfig, isEqual)\n  }\n  return useRecognizers<UseHoverConfig>({ hover: handler }, buildHoverConfig.value(config))\n}\n","import { UseMoveConfig, Handler, EventTypes } from '../types'\nimport { _buildMoveConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { ref } from 'vue-demi'\n\n/**\n * Move hook.\n *\n * @param handler - the function fired every time the move gesture updates\n * @param [config={}] - the config object including generic options and move options\n */\nexport function useMove<K = EventTypes['move']>(handler: Handler<'move', K>, config: UseMoveConfig | {} = {}) {\n  RecognizersMap.set('move', MoveRecognizer)\n  const buildMoveConfig = ref<any>()\n  if (!buildMoveConfig.value) {\n    buildMoveConfig.value = memoize(_buildMoveConfig, isEqual)\n  }\n  return useRecognizers<UseMoveConfig>({ move: handler }, buildMoveConfig.value(config))\n}\n","import { UsePinchConfig, Handler, EventTypes } from '../types'\nimport { _buildPinchConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { ref } from 'vue-demi'\n\n/**\n * Pinch hook.\n *\n * @param handler - the function fired every time the pinch gesture updates\n * @param [config={}] - the config object including generic options and pinch options\n */\nexport function usePinch<K = EventTypes['pinch']>(handler: Handler<'pinch', K>, config: UsePinchConfig | {} = {}) {\n  RecognizersMap.set('pinch', PinchRecognizer)\n  const buildPinchConfig = ref<any>()\n  if (!buildPinchConfig.value) {\n    buildPinchConfig.value = memoize(_buildPinchConfig, isEqual)\n  }\n  return useRecognizers<UsePinchConfig>({ pinch: handler }, buildPinchConfig.value(config))\n}\n","import { UseScrollConfig, Handler, EventTypes } from '../types'\nimport { _buildScrollConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\n// import { useRef } from 'react';\nimport { ref } from 'vue-demi'\n\n/**\n * Scroll hook.\n *\n * @param handler - the function fired every time the scroll gesture updates\n * @param [config={}] - the config object including generic options and scroll options\n */\nexport function useScroll<K = EventTypes['scroll']>(handler: Handler<'scroll', K>, config: UseScrollConfig | {} = {}) {\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  const buildScrollConfig = ref<any>()\n  if (!buildScrollConfig.value) {\n    buildScrollConfig.value = memoize(_buildScrollConfig, isEqual)\n  }\n  return useRecognizers<UseScrollConfig>({ scroll: handler }, buildScrollConfig.value(config))\n}\n","import { UseWheelConfig, Handler, EventTypes } from '../types'\nimport { _buildWheelConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { ref } from 'vue-demi'\n\n/**\n * Wheel hook.\n *\n * @param handler - the function fired every time the wheel gesture updates\n * @param the config object including generic options and wheel options\n */\nexport function useWheel<K = EventTypes['wheel']>(handler: Handler<'wheel', K>, config: UseWheelConfig | {} = {}) {\n  RecognizersMap.set('wheel', WheelRecognizer)\n  const buildWheelConfig = ref<any>()\n  if (!buildWheelConfig.value) {\n    buildWheelConfig.value = memoize(_buildWheelConfig, isEqual)\n  }\n  return useRecognizers<UseWheelConfig>({ wheel: handler }, buildWheelConfig.value(config))\n}\n"],"names":["addV","v1","v2","map","v","i","subV","calculateDistance","movement","Math","hypot","calculateAllGeometry","delta","dl","alpha","direction","distance","calculateAllKinematics","dt","beta","velocity","velocities","sign","x","Number","rubberband","dimension","constant","Infinity","abs","pow","rubberband2","rubberbandIfOutOfBounds","position","min","max","value","minMax","noop","chainFns","fns","length","result","fn","apply","this","arguments","ensureVector","fallback","undefined","Error","Array","isArray","assignDefault","Object","assign","valueFn","args","resolveWith","config","resolvers","entries","key","resolver","call","InternalGestureOptionsNormalizers","threshold","enabled","triggerAllEvents","initial","InternalCoordinatesOptionsNormalizers","axis","lockDirection","bounds","state","left","right","top","bottom","isBrowser","window","document","createElement","InternalGenericOptionsNormalizers","domTarget","eventOptions","passive","capture","InternalDistanceAngleOptionsNormalizers","_value","_key","distanceBounds","angleBounds","_distanceBounds","D","_angleBounds","A","InternalDragOptionsNormalizers","_k","filterTaps","swipeVelocity","swipeDistance","delay","getInternalGenericOptions","getInternalCoordinatesOptions","getInternalDistanceAngleOptions","getInternalDragOptions","_buildMoveConfig","rest","opts","move","_buildHoverConfig","hover","_buildDragConfig","drag","_buildPinchConfig","pinch","_buildScrollConfig","scroll","_buildWheelConfig","wheel","getInitial","mixed","_active","_blocked","_intentional","_movement","_initial","_bounds","_lastEventType","event","intentional","values","offset","lastOffset","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","getInitialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","touches","buttons","down","shiftKey","altKey","metaKey","ctrlKey","xy","vxvy","_isTap","_delayedEvent","_pointerId","tap","swipe","da","vdva","origin","turns","RecognizersMap","Map","Recognizer","controller","callback","ms","clearTimeout","_this","timeouts","stateKey","setTimeout","forceFlag","debounced","clean","prev_active","next_active","ingKey","mapStateValues","newMemo","handler","updateSharedState","sharedState","updateGestureState","gestureState","checkIntentionality","getMovement","T","wasIntentional","prevMovement","M","getInternalMovement","i0","getIntentionalDisplacement","i1","intentionalityCheck","__cachedBounds","__cachedInitial","_rubberband","computeRubberband","handlers","Vy","Ry","Y1","Y2","getGenericPayload","isStartEvent","type","getStartGestureState","recognizer","partial","func","Controller","classes","bindings","RecognizerClass","addBindings","nativeRefs","updateDomListeners","getPropsListener","bind","getDomTargetFromConfig","removeListeners","takeAll","domListeners","forEach","el","windowListeners","clearAllWindowListeners","clearWindowListeners","updateWindowListeners","listeners","addListeners","name","slice","toLowerCase","push","props","captureString","fnsArray","array","splice","options","addEventListener","removeEventListener","useRecognizers","nativeHandlers","internalHandlers","Set","add","get","resolveClasses","onMounted","effect","deprecationNoticeForDomTarget","CoordinatesRecognizer","absX","absY","getKinematics","getTouchEvents","targetTouches","changedTouches","getGenericEventData","touchEvents","getPointerEventValues","clientX","clientY","getScrollEventValues","currentTarget","scrollX","scrollLeft","scrollY","scrollTop","getWheelEventValues","deltaX","deltaY","getWebkitGestureEventValues","scale","rotation","getTwoTouchesEventData","B","dx","dy","cx","cy","e","atan2","PI","DragRecognizer","onDragChange","onDragEnd","pointerId","startDrag","genericEventData","kinematics","genericPayload","realDistance","fireGestureHandler","vx","vy","mx","my","ix","iy","svx","svy","sx","sy","endState","requestAnimationFrame","stopPropagation","onCancel","onDragStart","onClick","memoizeOne","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","a","b","equal","constructor","keys","it","size","next","done","has","RegExp","source","flags","valueOf","prototype","toString","hasOwnProperty","Element","$$typeof","error","message","match","console","warn","PinchRecognizer","pinchShouldStart","preventDefault","delta_d","prev_a","wheelShouldRun","onWheelEnd","onWheelChange","onWheelStart","getWheelValuesFromEvent","cancelable","ontouchstart","GestureEvent","supportsGestureEvents","onGestureStart","onGestureChange","onGestureEnd","onPinchStart","onPinchChange","onPinchEnd","onWheel","d","delta_a","next_turns","WheelRecognizer","onEnd","geometry","handleEvent","MoveRecognizer","onMoveEnd","onMoveChange","onMoveStart","onMove","onPointerEnter","onPointerLeave","ScrollRecognizer","movementDetection","RE_NOT_NATIVE","includeStartEndHandlers","handlerKey","startKey","endKey","noWobble","mass","tension","friction","precision","gentle","wobbly","stiff","presets","isClient","raf","cancelRaf","cancelAnimationFrame","now","performance","Date","isFunction","reusedTuple","stepper","secondPerFrame","destX","spring","newV","newX","defineInitialValues","newValues","newVelocities","set","buildDragConfig","ref","memoize","_handlers","native","handle","actions","test","lastMatch","sortHandlers","mergedConfig","buildComplexConfig","onHover","buildHoverConfig","buildMoveConfig","buildPinchConfig","buildScrollConfig","initialValue","springConfiguration","onRest","realValues","wasAnimating","prevTime","accumulatedTime","watch","_current","_old","animate","deep","animationId","current","currentValues","currentVelocities","idealValues","idealVelocities","shouldStopAnimation","currentTime","timeDelta","currentFrameCompletion","floor","framesToCatchUp","newIdealValue","newIdealVelocity","nextIdealVelocity","animateValues","ideal","onUnmounted","modifiableValues","computed","toRefs","reactive","rawValuesObject","immediate","buildWheelConfig"],"mappings":"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"}