/*!
  * vue-use-spring v0.0.1
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');

// the default, if nothing provided
const noWobble = {
    mass: 1,
    tension: 170,
    friction: 26,
    precision: 0.01,
};
const gentle = {
    mass: 1,
    tension: 120,
    friction: 14,
    precision: 0.01,
};
const wobbly = {
    mass: 1,
    tension: 180,
    friction: 12,
    precision: 0.01,
};
const stiff = {
    mass: 1,
    tension: 210,
    friction: 20,
    precision: 0.01,
};
const presets = { noWobble, gentle, wobbly, stiff };

const isClient = typeof window !== 'undefined';
const raf = isClient
    ? window.requestAnimationFrame.bind(window)
    : () => { };
const cancelRaf = isClient
    ? window.cancelAnimationFrame.bind(window)
    : () => { };
const now = typeof performance !== 'undefined'
    ? performance.now.bind(performance)
    : Date.now.bind(Date);
const isArray = Array.isArray.bind(Array);
// stepper is used a lot. Saves allocation to return the same array wrapper.
// This is fine and danger-free against mutations because the callsite
// immediately destructures it and gets the numbers inside without passing the
// array reference around.
const reusedTuple = [0, 0];
function stepper(secondPerFrame, x, v, destX, spring) {
    // Spring stiffness, in kg / s^2
    // for animations, destX is really spring length (spring at rest). initial
    // position is considered as the stretched/compressed position of a spring
    const Fspring = -spring.tension * (x - destX);
    // Damping, in kg / s
    const Fdamper = -spring.friction * v;
    const a = (Fspring + Fdamper) / (spring.mass || 1);
    const newV = v + a * secondPerFrame;
    const newX = x + newV * secondPerFrame;
    const precision = spring.precision || 0.01;
    if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {
        reusedTuple[0] = destX;
        reusedTuple[1] = 0;
        return reusedTuple;
    }
    reusedTuple[0] = newX;
    reusedTuple[1] = newV;
    return reusedTuple;
}

const msPerFrame = 1000 / 60;
function defineInitialValues(values, velocities) {
    const newValues = (isArray(values) ? [] : {});
    const newVelocities = (isArray(values) ? [] : {});
    for (const key in values) {
        newValues[key] = values[key];
        // @ts-ignore
        newVelocities[key] = velocities ? velocities[key] : 0;
    }
    return [newValues, newVelocities];
}
const noop = () => { };
/**
 * Returns an object with the same shape as initialValue but that interpolates
 * its value when set instead of directly changing.
 *
 * @example
 * ```js
 *   const position = useSpring({ x: 0, y: 100 })
 *   position.x = 100
 *   position.x // 0
 *   await delay(300) // wait some time
 *   // the position.x automatically increases until it reaches 100
 *   position.x // 70
 * ```
 *
 * @param initialValue initial value of the spring controlled variable
 * @param springConfiguration Spring properties. Can be a Ref or Computed
 * @param options Optional options
 */
function useSpring(initialValue, springConfiguration = noWobble, options = {}) {
    const spring = springConfiguration || noWobble;
    const onRest = options.onRest || noop;
    // hold a ref to real values so we can change them
    const realValues = vue.ref(initialValue);
    let wasAnimating = false;
    let prevTime = 0;
    let accumulatedTime = 0;
    vue.watch(realValues, (current, old) => {
        if (!wasAnimating) {
            prevTime = now();
            accumulatedTime = 0;
            animate();
        }
    }, { deep: true });
    const current = defineInitialValues(realValues.value, null);
    const currentValues = vue.ref(current[0]);
    const currentVelocities = vue.ref(current[1]);
    // only done to correctly infer types, they're overridden in mounted
    let idealValues = current[0];
    let idealVelocities = current[1];
    vue.onMounted(() => {
        prevTime = now();
        accumulatedTime = 0;
        const ideal = defineInitialValues(currentValues.value, currentVelocities.value);
        idealValues = ideal[0];
        idealVelocities = ideal[1];
        animate();
    });
    let animationId;
    // TODO: also cancel when a new value comes
    vue.onUnmounted(() => {
        if (animationId) {
            cancelRaf(animationId);
        }
    });
    function animate() {
        animationId = raf(() => {
            if (shouldStopAnimation(currentValues.value, realValues.value, currentVelocities.value)) {
                // TODO: emit
                if (wasAnimating)
                    onRest();
                // reset everything for next animation
                animationId = null;
                wasAnimating = false;
                return;
            }
            // TODO: emit
            // if (!wasAnimating) this.$emit('motion-start')
            wasAnimating = true;
            // get time from last frame
            const currentTime = now();
            const timeDelta = currentTime - prevTime;
            prevTime = currentTime;
            accumulatedTime += timeDelta;
            // more than 10 frames? probably switched browser tab. Restart
            if (accumulatedTime > msPerFrame * 10) {
                accumulatedTime = 0;
            }
            if (accumulatedTime === 0) {
                // no need to cancel animationID here; shouldn't have any in flight
                animationId = null;
                // TODO: emit
                // this.$emit('motion-restart')
                return animate();
            }
            const currentFrameCompletion = (accumulatedTime -
                Math.floor(accumulatedTime / msPerFrame) * msPerFrame) /
                msPerFrame;
            const framesToCatchUp = Math.floor(accumulatedTime / msPerFrame);
            animateValues(framesToCatchUp, currentFrameCompletion, vue.unref(spring), realValues.value, currentValues.value, currentVelocities.value, idealValues, idealVelocities);
            // out of the update loop
            animationId = null;
            // the amount we're looped over above
            accumulatedTime -= framesToCatchUp * msPerFrame;
            // keep going!
            animate();
        });
    }
    const modifiableValues = (isArray(realValues.value) ? [] : {});
    for (const key in realValues.value) {
        // @ts-ignore
        modifiableValues[key] = vue.computed({
            // @ts-ignore
            get: () => currentValues.value[key],
            // @ts-ignore
            set: (v) => (realValues.value[key] = v),
        });
    }
    // @ts-ignore
    modifiableValues.reset = (v) => {
        // console.log('setting', v)
        // for (const key in v) {
        //   // @ts-ignore
        //   currentValues.value[key] = v[key]
        //   // @ts-ignore
        //   realValues.value[key] = v[key]
        // }
        Object.assign(currentValues.value, v);
        Object.assign(realValues.value, v);
        wasAnimating = false;
        animationId = null;
        // for (const key in currentVelocities.value) {
        // @ts-ignore: reset speed
        // currentVelocities.value[key] = 0
        // }
    };
    return vue.reactive(modifiableValues);
}
function shouldStopAnimation(currentValues, values, currentVelocities) {
    for (const key in values) {
        // istanbul ignore if
        // if (!Object.prototype.hasOwnProperty.call(values, key)) continue
        // Something is still moving
        if (currentVelocities[key] !== 0)
            return false;
        // Something hasn't reached its destination
        // stepper will have already taken care of rounding precision errors, so
        // won't have such thing as 0.9999 != 1
        if (currentValues[key] !==
            values[key])
            return false;
    }
    return true;
}
function animateValues(framesToCatchUp, currentFrameCompletion, spring, realValues, currentValues, currentVelocities, idealValues, idealVelocities) {
    for (const key in realValues) {
        // istanbul ignore if
        // if (!Object.prototype.hasOwnProperty.call(realValues, key)) continue
        let newIdealValue = idealValues[key];
        let newIdealVelocity = idealVelocities[key];
        const value = realValues[key];
        // iterate as if the animation took place
        for (let i = 0; i < framesToCatchUp; i++) {
            [newIdealValue, newIdealVelocity] = stepper(msPerFrame / 1000, newIdealValue, newIdealVelocity, value, spring);
        }
        const [nextIdealValue, nextIdealVelocity] = stepper(msPerFrame / 1000, newIdealValue, newIdealVelocity, value, spring);
        // @ts-ignore
        currentValues[key] =
            newIdealValue + (nextIdealValue - newIdealValue) * currentFrameCompletion;
        // @ts-ignore
        currentVelocities[key] =
            newIdealVelocity +
                (nextIdealVelocity - newIdealVelocity) * currentFrameCompletion;
        // @ts-ignore
        idealValues[key] = newIdealValue;
        // @ts-ignore
        idealVelocities[key] = newIdealVelocity;
    }
}

// import {
const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = vue.defineComponent({
    name: 'TransitionGroup',
    props: {
        config: Object,
        tag: String,
    },
    setup(props, { slots }) {
        // const instance = getCurrentInstance()!
        // const state = useTransitionState()
        // TODO: const positions = useSprings(childrenKeys, {x: 0, y:0})
        const pos1 = useSpring({ x: 0, y: 0 });
        const pos2 = useSpring({ x: 0, y: 0 });
        const pos3 = useSpring({ x: 0, y: 0 });
        const pos4 = useSpring({ x: 0, y: 0 });
        const positions = {
            Ipsum: pos1,
            Lorem: pos2,
            Dolor: pos3,
            Sit: pos4,
        };
        let prevChildren;
        let children;
        // @ts-ignore
        window.pos2 = pos2;
        vue.watch(() => pos2, () => {
            const name = 'Lorem';
            console.log('watch pos2');
            const child = children.find((c) => c.key === name);
            if (!child) {
                console.log('not found', name);
            }
            else {
                const s = child.el.style;
                const dx = pos2.x;
                const dy = pos2.y;
                console.log('watch Lorem', { dx, dy });
                s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
            }
        }, { deep: true, flush: 'post' });
        // watch(
        //   () => [pos1, pos2, pos3, pos4],
        //   () => {
        //     console.log('trigger')
        //     for (const name in positions) {
        //       const child = children.find((c) => c.key === name)
        //       if (!child) {
        //         console.log('not found', name)
        //       } else {
        //         const s = (child.el as HTMLElement).style
        //         const dx = positions[name].x
        //         const dy = positions[name].y
        //         if (name === 'Lorem') console.log('Lorem', { dx, dy })
        //         s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`
        //       }
        //     }
        //   },
        //   { deep: false, flush: 'post' }
        // )
        vue.onUpdated(() => {
            // children is guaranteed to exist after initial render
            if (!prevChildren.length) {
                return;
            }
            // const moveClass = props.moveClass || `${props.name || 'v'}-move`
            // if (
            //   !hasCSSTransform(
            //     prevChildren[0].el as ElementWithTransition,
            //     instance.vnode.el as Node,
            //     moveClass
            //   )
            // ) {
            //   return
            // }
            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            // prevChildren.forEach(callPendingCbs)
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter((c) => applyTranslation(c, positions));
            // force reflow to put everything in position
            forceReflow();
            movedChildren.forEach((c) => {
                const el = c.el;
                // const style = el.style
                // addTransitionClass(el, moveClass)
                setTimeout(() => {
                    pos2.x = 0;
                    pos2.y = 0;
                    // positions[c.key!].x = 0
                    // positions[c.key!].y = 0
                    console.log('moved', c.key);
                }, 1000);
                // style.transform = style.webkitTransform = style.transitionDuration = ''
                const cb = (el._moveCb = (e) => {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener('transitionend', cb);
                        el._moveCb = null;
                        // removeTransitionClass(el, moveClass)
                    }
                });
                el.addEventListener('transitionend', cb);
            });
        });
        return () => {
            const rawProps = vue.toRaw(props);
            // const cssTransitionProps = resolveTransitionProps(rawProps)
            const tag = rawProps.tag || vue.Fragment;
            prevChildren = children;
            children = slots.default ? vue.getTransitionRawChildren(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.key != null) ;
                else {
                    vue.warn(`<TransitionGroup> children must be keyed.`);
                }
            }
            if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                    const child = prevChildren[i];
                    // setTransitionHooks(
                    //   child,
                    //   resolveTransitionHooks(child, {}, state, instance)
                    // )
                    positionMap.set(child, child.el.getBoundingClientRect());
                    console.log('saved before render', child.key, child.el.getBoundingClientRect());
                }
            }
            return vue.createVNode(tag, null, children);
        };
    },
});
const SpringGroup = TransitionGroupImpl;
// function callPendingCbs(c: VNode) {
//   const el = c.el as any
//   if (el._moveCb) {
//     el._moveCb()
//   }
//   if (el._enterCb) {
//     el._enterCb()
//   }
// }
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
    console.log('saved after render', c.key, c.el.getBoundingClientRect());
}
function applyTranslation(c, positions) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    // @ts-ignore
    if (c.key === 'Lorem')
        pos2.reset({ x: dx, y: dy });
    // positions[c.key!].reset({ x: dx, y: dy })
    // positions[c.key!].x = dx
    // positions[c.key!].y = dy
    console.log('reset', c.key, { ...positions[c.key] });
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
        return c;
    }
}
// this is put in a dedicated function to avoid the line from being treeshaken
function forceReflow() {
    return document.body.offsetHeight;
}
// function hasCSSTransform(
//   el: ElementWithTransition,
//   root: Node,
//   moveClass: string
// ): boolean {
//   // Detect whether an element with the move class applied has
//   // CSS transitions. Since the element may be inside an entering
//   // transition at this very moment, we make a clone of it and remove
//   // all other transition classes applied to ensure only the move class
//   // is applied.
//   const clone = el.cloneNode() as HTMLElement
//   if (el._vtc) {
//     el._vtc.forEach((cls) => {
//       cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c))
//     })
//   }
//   moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c))
//   clone.style.display = 'none'
//   const container = (root.nodeType === 1
//     ? root
//     : root.parentNode) as HTMLElement
//   container.appendChild(clone)
//   const { hasTransform } = getTransitionInfo(clone)
//   container.removeChild(clone)
//   return hasTransform
// }

exports.SpringGroup = SpringGroup;
exports.gentle = gentle;
exports.noWobble = noWobble;
exports.presets = presets;
exports.stiff = stiff;
exports.useSpring = useSpring;
exports.wobbly = wobbly;
